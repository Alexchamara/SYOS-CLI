<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/domain/repository/WebUserRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/domain/repository/WebUserRepository.java" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="// This file is deprecated and should be deleted.&#10;// The CustomerRepository interface has been moved to CustomerRepository.java&#10;// This file is kept only to avoid breaking any existing imports during transition." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/infrastructure/persistence/JdbcWebUserRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/infrastructure/persistence/JdbcWebUserRepository.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package main.java.infrastructure.persistence;&#10;&#10;import main.java.domain.model.User;&#10;import main.java.domain.repository.CustomerRepository;&#10;&#10;import javax.sql.DataSource;&#10;import java.sql.Connection;&#10;import java.sql.PreparedStatement;&#10;import java.sql.ResultSet;&#10;import java.sql.Statement;&#10;&#10;/**&#10; * JDBC implementation of CustomerRepository&#10; */&#10;public final class JdbcCustomerRepository implements CustomerRepository {&#10;    private final DataSource dataSource;&#10;&#10;    public JdbcCustomerRepository(DataSource dataSource) {&#10;        this.dataSource = dataSource;&#10;    }&#10;&#10;    @Override&#10;    public long create(String email, String passwordHash, String fullName) {&#10;        try (Connection con = dataSource.getConnection();&#10;             PreparedStatement ps = con.prepareStatement(&#10;                     &quot;INSERT INTO users (email, password_hash, full_name, role, username, created_at) VALUES (?, ?, ?, 'USER', ?, NOW())&quot;,&#10;                     Statement.RETURN_GENERATED_KEYS)) {&#10;&#10;            ps.setString(1, email);&#10;            ps.setString(2, passwordHash);&#10;            ps.setString(3, fullName);&#10;            ps.setString(4, email); // Use email as username for WEB users&#10;&#10;            ps.executeUpdate();&#10;&#10;            try (ResultSet rs = ps.getGeneratedKeys()) {&#10;                if (rs.next()) {&#10;                    return rs.getLong(1);&#10;                }&#10;                throw new RuntimeException(&quot;Failed to get generated user ID&quot;);&#10;            }&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;Failed to create user&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public User findByEmail(String email) {&#10;        try (Connection con = dataSource.getConnection();&#10;             PreparedStatement ps = con.prepareStatement(&#10;                     &quot;SELECT id, email, full_name FROM users WHERE email = ? AND role = 'USER'&quot;)) {&#10;&#10;            ps.setString(1, email);&#10;&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return new User(&#10;                            rs.getLong(&quot;id&quot;),&#10;                            rs.getString(&quot;email&quot;),&#10;                            rs.getString(&quot;full_name&quot;)&#10;                    );&#10;                }&#10;                return null;&#10;            }&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;Failed to find user by email&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public String passwordHashByEmail(String email) {&#10;        try (Connection con = dataSource.getConnection();&#10;             PreparedStatement ps = con.prepareStatement(&#10;                     &quot;SELECT password_hash FROM users WHERE email = ? AND role = 'USER'&quot;)) {&#10;&#10;            ps.setString(1, email);&#10;&#10;            try (ResultSet rs = ps.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return rs.getString(&quot;password_hash&quot;);&#10;                }&#10;                return null;&#10;            }&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;Failed to get password hash&quot;, e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/db/migration/V16__create_orders_tables.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/db/migration/V16__create_orders_tables.sql" />
              <option name="updatedContent" value="-- Create orders table for web shop orders&#10;CREATE TABLE orders (&#10;    id BIGINT AUTO_INCREMENT PRIMARY KEY,&#10;    bill_serial BIGINT NOT NULL,&#10;    type VARCHAR(20) NOT NULL,&#10;    location VARCHAR(20) NOT NULL,&#10;    user_id BIGINT,&#10;    total_gross DECIMAL(10,2) NOT NULL,&#10;    discount DECIMAL(10,2) NOT NULL DEFAULT 0,&#10;    total_net DECIMAL(10,2) NOT NULL,&#10;    status VARCHAR(20) NOT NULL DEFAULT 'PREVIEW',&#10;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,&#10;    FOREIGN KEY (user_id) REFERENCES customers(id) ON DELETE SET NULL&#10;);&#10;&#10;-- Create order_lines table for web shop order items&#10;CREATE TABLE order_lines (&#10;    id BIGINT AUTO_INCREMENT PRIMARY KEY,&#10;    order_id BIGINT NOT NULL,&#10;    product_code VARCHAR(50) NOT NULL,&#10;    name VARCHAR(255) NOT NULL,&#10;    unit_price DECIMAL(10,2) NOT NULL,&#10;    qty INT NOT NULL,&#10;    line_total DECIMAL(10,2) NOT NULL,&#10;    FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE&#10;);&#10;&#10;-- Create payments table for web shop payments&#10;CREATE TABLE payments (&#10;    id BIGINT AUTO_INCREMENT PRIMARY KEY,&#10;    order_id BIGINT NOT NULL,&#10;    payment_type VARCHAR(20) NOT NULL DEFAULT 'CARD',&#10;    card_last4 VARCHAR(4),&#10;    auth_reference VARCHAR(100),&#10;    amount DECIMAL(10,2) NOT NULL,&#10;    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;    FOREIGN KEY (order_id) REFERENCES orders(id) ON DELETE CASCADE&#10;);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/AppTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/AppTest.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.AfterEach;&#10;import org.junit.jupiter.api.Nested;&#10;import org.mockito.MockedStatic;&#10;import org.mockito.MockedConstruction;&#10;import org.mockito.Mockito;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.Mockito.*;&#10;&#10;import java.io.ByteArrayInputStream;&#10;import java.io.ByteArrayOutputStream;&#10;import java.io.InputStream;&#10;import java.io.PrintStream;&#10;import java.util.Scanner;&#10;import java.util.Optional;&#10;import javax.sql.DataSource;&#10;&#10;import main.java.App;&#10;import config.Db;&#10;import infrastructure.concurrency.Tx;&#10;import infrastructure.persistence.*;&#10;import infrastructure.security.PasswordEncoder;&#10;import infrastructure.events.SimpleBus;&#10;import infrastructure.events.LowStockPrinter;&#10;import application.usecase.*;&#10;import application.services.*;&#10;import cli.signin.LoginScreen;&#10;import cli.cashier.CashierMenu;&#10;import cli.manager.ManagerMenu;&#10;import cli.webshop.WebShopMenu;&#10;import cli.SeedUsers;&#10;import domain.user.User;&#10;import domain.user.Role;&#10;&#10;@DisplayName(&quot;App Tests&quot;)&#10;class AppTest {&#10;&#10;    private final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();&#10;    private final PrintStream originalOut = System.out;&#10;    private final InputStream originalIn = System.in;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        System.setOut(new PrintStream(outputStream));&#10;    }&#10;&#10;    @AfterEach&#10;    void tearDown() {&#10;        System.setOut(originalOut);&#10;        System.setIn(originalIn);&#10;    }&#10;&#10;    @Nested&#10;    @DisplayName(&quot;Main Method Tests&quot;)&#10;    class MainMethodTests {&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should start CLI interface when user chooses option 1&quot;)&#10;        void shouldStartCliInterfaceWhenUserChoosesOption1() {&#10;            // Given&#10;            String userInput = &quot;1\nmanager\npassword\n0\n&quot;; // Choose CLI, login as manager, exit&#10;            setSystemInput(userInput);&#10;&#10;            try (MockedStatic&lt;SeedUsers&gt; seedUsersMock = mockStatic(SeedUsers.class);&#10;                 MockedConstruction&lt;Db&gt; dbMock = mockConstruction(Db.class, AppTest.this::setupDbMock);&#10;                 MockedConstruction&lt;Scanner&gt; scannerMock = mockConstruction(Scanner.class, AppTest.this::setupScannerMock);&#10;                 MockedConstruction&lt;LoginScreen&gt; loginMock = mockConstruction(LoginScreen.class, AppTest.this::setupLoginScreenMock);&#10;                 MockedConstruction&lt;CashierMenu&gt; cashierMock = mockConstruction(CashierMenu.class);&#10;                 MockedConstruction&lt;ManagerMenu&gt; managerMock = mockConstruction(ManagerMenu.class, AppTest.this::setupManagerMenuMock);&#10;                 MockedStatic&lt;App&gt; appMock = mockStatic(App.class)) {&#10;&#10;                // Mock the main method to avoid OnlineCartUseCase instantiation&#10;                appMock.when(() -&gt; App.main(any())).thenCallRealMethod();&#10;&#10;                // When&#10;                assertDoesNotThrow(() -&gt; App.main(new String[]{}));&#10;&#10;                // Then&#10;                seedUsersMock.verify(() -&gt; SeedUsers.ensure(any(), any()));&#10;            }&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should start Web Shop interface when user chooses option 2&quot;)&#10;        void shouldStartWebShopInterfaceWhenUserChoosesOption2() {&#10;            // Given&#10;            String userInput = &quot;2\n&quot;;&#10;            setSystemInput(userInput);&#10;&#10;            try (MockedStatic&lt;SeedUsers&gt; seedUsersMock = mockStatic(SeedUsers.class);&#10;                 MockedConstruction&lt;Db&gt; dbMock = mockConstruction(Db.class, AppTest.this::setupDbMock);&#10;                 MockedConstruction&lt;Scanner&gt; scannerMock = mockConstruction(Scanner.class, AppTest.this::setupScannerMock);&#10;                 MockedConstruction&lt;WebShopMenu&gt; webShopMock = mockConstruction(WebShopMenu.class, AppTest.this::setupWebShopMenuMock);&#10;                 MockedStatic&lt;App&gt; appMock = mockStatic(App.class)) {&#10;&#10;                // Mock the main method to avoid OnlineCartUseCase instantiation&#10;                appMock.when(() -&gt; App.main(any())).thenCallRealMethod();&#10;&#10;                // When&#10;                assertDoesNotThrow(() -&gt; App.main(new String[]{}));&#10;&#10;                // Then&#10;                seedUsersMock.verify(() -&gt; SeedUsers.ensure(any(), any()));&#10;            }&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should handle invalid interface choice&quot;)&#10;        void shouldHandleInvalidInterfaceChoice() {&#10;            // Given&#10;            String userInput = &quot;3\n&quot;; // Invalid choice&#10;            setSystemInput(userInput);&#10;&#10;            try (MockedStatic&lt;SeedUsers&gt; seedUsersMock = mockStatic(SeedUsers.class);&#10;                 MockedConstruction&lt;Db&gt; dbMock = mockConstruction(Db.class, AppTest.this::setupDbMock);&#10;                 MockedConstruction&lt;Scanner&gt; scannerMock = mockConstruction(Scanner.class, AppTest.this::setupScannerMock);&#10;                 MockedStatic&lt;App&gt; appMock = mockStatic(App.class)) {&#10;&#10;                // Mock the main method to avoid OnlineCartUseCase instantiation&#10;                appMock.when(() -&gt; App.main(any())).thenCallRealMethod();&#10;&#10;                // When&#10;                assertDoesNotThrow(() -&gt; App.main(new String[]{}));&#10;&#10;                // Then&#10;                String output = outputStream.toString();&#10;                seedUsersMock.verify(() -&gt; SeedUsers.ensure(any(), any()));&#10;            }&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should handle empty command line arguments&quot;)&#10;        void shouldHandleEmptyCommandLineArguments() {&#10;            // Given&#10;            String userInput = &quot;3\n&quot;; // Invalid choice to exit quickly&#10;            setSystemInput(userInput);&#10;&#10;            try (MockedStatic&lt;SeedUsers&gt; seedUsersMock = mockStatic(SeedUsers.class);&#10;                 MockedConstruction&lt;Db&gt; dbMock = mockConstruction(Db.class, AppTest.this::setupDbMock);&#10;                 MockedConstruction&lt;Scanner&gt; scannerMock = mockConstruction(Scanner.class, AppTest.this::setupScannerMock)) {&#10;&#10;                // When &amp; Then&#10;                assertDoesNotThrow(() -&gt; App.main(new String[]{}));&#10;                seedUsersMock.verify(() -&gt; SeedUsers.ensure(any(), any()));&#10;            }&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should handle null command line arguments&quot;)&#10;        void shouldHandleNullCommandLineArguments() {&#10;            // Given&#10;            String userInput = &quot;3\n&quot;; // Invalid choice to exit quickly&#10;            setSystemInput(userInput);&#10;&#10;            try (MockedStatic&lt;SeedUsers&gt; seedUsersMock = mockStatic(SeedUsers.class);&#10;                 MockedConstruction&lt;Db&gt; dbMock = mockConstruction(Db.class, AppTest.this::setupDbMock);&#10;                 MockedConstruction&lt;Scanner&gt; scannerMock = mockConstruction(Scanner.class, AppTest.this::setupScannerMock)) {&#10;&#10;                // When &amp; Then&#10;                assertDoesNotThrow(() -&gt; App.main(null));&#10;                seedUsersMock.verify(() -&gt; SeedUsers.ensure(any(), any()));&#10;            }&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should create all required repositories and services&quot;)&#10;        void shouldCreateAllRequiredRepositoriesAndServices() {&#10;            // Given&#10;            String userInput = &quot;3\n&quot;; // Invalid choice to exit quickly&#10;            setSystemInput(userInput);&#10;&#10;            try (MockedStatic&lt;SeedUsers&gt; seedUsersMock = mockStatic(SeedUsers.class);&#10;                 MockedConstruction&lt;Db&gt; dbMock = mockConstruction(Db.class, AppTest.this::setupDbMock);&#10;                 MockedConstruction&lt;Scanner&gt; scannerMock = mockConstruction(Scanner.class, AppTest.this::setupScannerMock);&#10;                 MockedConstruction&lt;JdbcProductRepository&gt; productRepoMock = mockConstruction(JdbcProductRepository.class);&#10;                 MockedConstruction&lt;JdbcCategoryRepository&gt; categoryRepoMock = mockConstruction(JdbcCategoryRepository.class);&#10;                 MockedConstruction&lt;JdbcBillRepository&gt; billRepoMock = mockConstruction(JdbcBillRepository.class);&#10;                 MockedConstruction&lt;JdbcInventoryRepository&gt; inventoryRepoMock = mockConstruction(JdbcInventoryRepository.class);&#10;                 MockedConstruction&lt;JdbcUserRepository&gt; userRepoMock = mockConstruction(JdbcUserRepository.class);&#10;                 MockedConstruction&lt;JdbcShortageEventRepository&gt; shortageRepoMock = mockConstruction(JdbcShortageEventRepository.class);&#10;                 MockedConstruction&lt;SimpleBus&gt; busMock = mockConstruction(SimpleBus.class);&#10;                 MockedConstruction&lt;PasswordEncoder&gt; encoderMock = mockConstruction(PasswordEncoder.class)) {&#10;&#10;                // When&#10;                assertDoesNotThrow(() -&gt; App.main(new String[]{}));&#10;&#10;                // Then - Verify basic dependency creation (repositories should be created)&#10;                assertTrue(productRepoMock.constructed().size() &gt;= 1);&#10;                assertTrue(categoryRepoMock.constructed().size() &gt;= 1);&#10;                assertTrue(billRepoMock.constructed().size() &gt;= 1);&#10;                assertTrue(inventoryRepoMock.constructed().size() &gt;= 1);&#10;                assertTrue(userRepoMock.constructed().size() &gt;= 1);&#10;                assertTrue(shortageRepoMock.constructed().size() &gt;= 1);&#10;                assertTrue(busMock.constructed().size() &gt;= 1);&#10;                assertTrue(encoderMock.constructed().size() &gt;= 1);&#10;            }&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should handle database connection failure gracefully&quot;)&#10;        void shouldHandleDatabaseConnectionFailureGracefully() {&#10;            // Given&#10;            String userInput = &quot;1\n&quot;;&#10;            setSystemInput(userInput);&#10;&#10;            try (MockedConstruction&lt;Db&gt; dbMock = mockConstruction(Db.class, (mock, context) -&gt; {&#10;                when(mock.getDataSource()).thenThrow(new RuntimeException(&quot;Database connection failed&quot;));&#10;            })) {&#10;&#10;                // When &amp; Then&#10;                RuntimeException exception = assertThrows(RuntimeException.class, () -&gt; App.main(new String[]{}));&#10;                assertTrue(exception.getMessage().contains(&quot;Database connection failed&quot;) || &#10;                          exception.getCause().getMessage().contains(&quot;Database connection failed&quot;));&#10;            }&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should handle various input scenarios&quot;)&#10;        void shouldHandleVariousInputScenarios() {&#10;            // Test empty input&#10;            setSystemInput(&quot;\n3\n&quot;);&#10;            assertDoesNotThrow(() -&gt; App.main(new String[]{}));&#10;&#10;            // Test whitespace input&#10;            setSystemInput(&quot;   \n3\n&quot;);&#10;            assertDoesNotThrow(() -&gt; App.main(new String[]{}));&#10;&#10;            // Test multiple invalid choices&#10;            setSystemInput(&quot;abc\n999\n-1\n3\n&quot;);&#10;            assertDoesNotThrow(() -&gt; App.main(new String[]{}));&#10;        }&#10;    }&#10;&#10;    @Nested&#10;    @DisplayName(&quot;Dependency Injection Tests&quot;)&#10;    class DependencyInjectionTests {&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should initialize core application components&quot;)&#10;        void shouldInitializeCoreApplicationComponents() {&#10;            // Given&#10;            String userInput = &quot;3\n&quot;; // Invalid choice to exit quickly&#10;            setSystemInput(userInput);&#10;&#10;            try (MockedStatic&lt;SeedUsers&gt; seedUsersMock = mockStatic(SeedUsers.class);&#10;                 MockedConstruction&lt;Db&gt; dbMock = mockConstruction(Db.class, AppTest.this::setupDbMock);&#10;                 MockedConstruction&lt;Scanner&gt; scannerMock = mockConstruction(Scanner.class, AppTest.this::setupScannerMock);&#10;                 MockedConstruction&lt;Tx&gt; txMock = mockConstruction(Tx.class);&#10;                 MockedConstruction&lt;AuthenticationUseCase&gt; authMock = mockConstruction(AuthenticationUseCase.class);&#10;                 MockedConstruction&lt;ProductManagementUseCase&gt; productMgmtMock = mockConstruction(ProductManagementUseCase.class);&#10;                 MockedConstruction&lt;CategoryManagementUseCase&gt; categoryMgmtMock = mockConstruction(CategoryManagementUseCase.class);&#10;                 MockedConstruction&lt;BatchManagementUseCase&gt; batchMgmtMock = mockConstruction(BatchManagementUseCase.class);&#10;                 MockedConstruction&lt;CheckoutUseCase&gt; checkoutMock = mockConstruction(CheckoutUseCase.class)) {&#10;&#10;                // When&#10;                assertDoesNotThrow(() -&gt; App.main(new String[]{}));&#10;&#10;                // Then - Verify core components are created&#10;                assertTrue(txMock.constructed().size() &gt;= 1);&#10;                assertTrue(authMock.constructed().size() &gt;= 1);&#10;                assertTrue(productMgmtMock.constructed().size() &gt;= 1);&#10;                assertTrue(categoryMgmtMock.constructed().size() &gt;= 1);&#10;                assertTrue(batchMgmtMock.constructed().size() &gt;= 1);&#10;                assertTrue(checkoutMock.constructed().size() &gt;= 1);&#10;            }&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should initialize service layer components&quot;)&#10;        void shouldInitializeServiceLayerComponents() {&#10;            // Given&#10;            String userInput = &quot;3\n&quot;; // Invalid choice to exit quickly&#10;            setSystemInput(userInput);&#10;&#10;            try (MockedStatic&lt;SeedUsers&gt; seedUsersMock = mockStatic(SeedUsers.class);&#10;                 MockedConstruction&lt;Db&gt; dbMock = mockConstruction(Db.class, AppTest.this::setupDbMock);&#10;                 MockedConstruction&lt;Scanner&gt; scannerMock = mockConstruction(Scanner.class, AppTest.this::setupScannerMock);&#10;                 MockedConstruction&lt;BillNumberService&gt; billNumberMock = mockConstruction(BillNumberService.class);&#10;                 MockedConstruction&lt;AvailabilityService&gt; availabilityMock = mockConstruction(AvailabilityService.class);&#10;                 MockedConstruction&lt;MainStoreService&gt; mainStoreMock = mockConstruction(MainStoreService.class);&#10;                 MockedConstruction&lt;ShortageEventService&gt; shortageMock = mockConstruction(ShortageEventService.class);&#10;                 MockedConstruction&lt;DiscountService&gt; discountMock = mockConstruction(DiscountService.class)) {&#10;&#10;                // When&#10;                assertDoesNotThrow(() -&gt; App.main(new String[]{}));&#10;&#10;                // Then - Verify service components are created&#10;                assertTrue(billNumberMock.constructed().size() &gt;= 1);&#10;                assertTrue(availabilityMock.constructed().size() &gt;= 1);&#10;                assertTrue(mainStoreMock.constructed().size() &gt;= 1);&#10;                assertTrue(shortageMock.constructed().size() &gt;= 1);&#10;                assertTrue(discountMock.constructed().size() &gt;= 1);&#10;            }&#10;        }&#10;    }&#10;&#10;    @Nested&#10;    @DisplayName(&quot;Error Handling Tests&quot;)&#10;    class ErrorHandlingTests {&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should handle system resource exhaustion&quot;)&#10;        void shouldHandleSystemResourceExhaustion() {&#10;            // Given&#10;            String userInput = &quot;3\n&quot;;&#10;            setSystemInput(userInput);&#10;&#10;            try (MockedConstruction&lt;Db&gt; dbMock = mockConstruction(Db.class, (mock, context) -&gt; {&#10;                when(mock.getDataSource()).thenThrow(new OutOfMemoryError(&quot;Heap space exhausted&quot;));&#10;            })) {&#10;&#10;                // When &amp; Then&#10;                assertThrows(OutOfMemoryError.class, () -&gt; App.main(new String[]{}));&#10;            }&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should handle security manager restrictions&quot;)&#10;        void shouldHandleSecurityManagerRestrictions() {&#10;            // Given&#10;            String userInput = &quot;3\n&quot;;&#10;            setSystemInput(userInput);&#10;&#10;            try (MockedStatic&lt;System&gt; systemMock = mockStatic(System.class)) {&#10;                systemMock.when(() -&gt; System.setIn(any())).thenThrow(new SecurityException(&quot;Access denied&quot;));&#10;&#10;                // When &amp; Then&#10;                assertThrows(SecurityException.class, () -&gt; setSystemInput(userInput));&#10;            }&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should handle application startup exceptions&quot;)&#10;        void shouldHandleApplicationStartupExceptions() {&#10;            // Given&#10;            String userInput = &quot;1\n&quot;;&#10;            setSystemInput(userInput);&#10;&#10;            try (MockedStatic&lt;SeedUsers&gt; seedUsersMock = mockStatic(SeedUsers.class)) {&#10;                seedUsersMock.when(() -&gt; SeedUsers.ensure(any(), any()))&#10;                    .thenThrow(new RuntimeException(&quot;User seeding failed&quot;));&#10;&#10;                // When &amp; Then&#10;                assertThrows(RuntimeException.class, () -&gt; App.main(new String[]{}));&#10;            }&#10;        }&#10;    }&#10;&#10;    @Nested&#10;    @DisplayName(&quot;Integration Tests&quot;)&#10;    class IntegrationTests {&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should complete application lifecycle&quot;)&#10;        void shouldCompleteApplicationLifecycle() {&#10;            // Given&#10;            String userInput = &quot;3\n&quot;; // Start and exit immediately&#10;            setSystemInput(userInput);&#10;&#10;            try (MockedStatic&lt;SeedUsers&gt; seedUsersMock = mockStatic(SeedUsers.class);&#10;                 MockedConstruction&lt;Db&gt; dbMock = mockConstruction(Db.class, AppTest.this::setupDbMock);&#10;                 MockedConstruction&lt;Scanner&gt; scannerMock = mockConstruction(Scanner.class, AppTest.this::setupScannerMock)) {&#10;&#10;                // When&#10;                assertDoesNotThrow(() -&gt; App.main(new String[]{}));&#10;&#10;                // Then&#10;                seedUsersMock.verify(() -&gt; SeedUsers.ensure(any(), any()));&#10;                assertEquals(1, dbMock.constructed().size());&#10;                assertEquals(1, scannerMock.constructed().size());&#10;            }&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should handle multiple execution scenarios&quot;)&#10;        void shouldHandleMultipleExecutionScenarios() {&#10;            // Test scenario 1: Normal CLI flow&#10;            String userInput1 = &quot;1\n3\n&quot;; // CLI then invalid choice&#10;            setSystemInput(userInput1);&#10;            assertDoesNotThrow(() -&gt; App.main(new String[]{}));&#10;&#10;            // Test scenario 2: Web shop flow&#10;            String userInput2 = &quot;2\n&quot;;&#10;            setSystemInput(userInput2);&#10;            assertDoesNotThrow(() -&gt; App.main(new String[]{}));&#10;&#10;            // Test scenario 3: Immediate exit&#10;            String userInput3 = &quot;3\n&quot;;&#10;            setSystemInput(userInput3);&#10;            assertDoesNotThrow(() -&gt; App.main(new String[]{}));&#10;        }&#10;&#10;        @Test&#10;        @DisplayName(&quot;Should maintain state consistency across operations&quot;)&#10;        void shouldMaintainStateConsistencyAcrossOperations() {&#10;            // Given&#10;            String userInput = &quot;3\n&quot;;&#10;            setSystemInput(userInput);&#10;&#10;            try (MockedStatic&lt;SeedUsers&gt; seedUsersMock = mockStatic(SeedUsers.class);&#10;                 MockedConstruction&lt;Db&gt; dbMock = mockConstruction(Db.class, AppTest.this::setupDbMock)) {&#10;&#10;                // When&#10;                assertDoesNotThrow(() -&gt; App.main(new String[]{}));&#10;&#10;                // Then - Verify consistent state&#10;                seedUsersMock.verify(() -&gt; SeedUsers.ensure(any(), any()));&#10;                assertEquals(1, dbMock.constructed().size());&#10;                &#10;                // Verify DataSource was properly accessed&#10;                verify(dbMock.constructed().get(0)).getDataSource();&#10;            }&#10;        }&#10;    }&#10;&#10;    // Helper methods for setting up mocks&#10;    private void setSystemInput(String input) {&#10;        System.setIn(new ByteArrayInputStream(input.getBytes()));&#10;    }&#10;&#10;    private void setupDbMock(Db db, MockedConstruction.Context context) {&#10;        DataSource mockDataSource = mock(DataSource.class);&#10;        when(db.getDataSource()).thenReturn(mockDataSource);&#10;    }&#10;&#10;    private void setupScannerMock(Scanner scanner, MockedConstruction.Context context) {&#10;        // Scanner behavior is handled by System.in redirection&#10;    }&#10;&#10;    private void setupLoginScreenMock(LoginScreen loginScreen, MockedConstruction.Context context) {&#10;        AuthenticationUseCase.Session mockSession = mock(AuthenticationUseCase.Session.class);&#10;        when(mockSession.identifier()).thenReturn(&quot;manager&quot;);&#10;        when(mockSession.role()).thenReturn(Role.MANAGER);&#10;        when(loginScreen.prompt()).thenReturn(mockSession);&#10;    }&#10;&#10;    private void setupFailedLoginScreenMock(LoginScreen loginScreen, MockedConstruction.Context context) {&#10;        when(loginScreen.prompt()).thenReturn(null);&#10;    }&#10;&#10;    private void setupCashierLoginScreenMock(LoginScreen loginScreen, MockedConstruction.Context context) {&#10;        AuthenticationUseCase.Session mockSession = mock(AuthenticationUseCase.Session.class);&#10;        when(mockSession.identifier()).thenReturn(&quot;cashier&quot;);&#10;        when(mockSession.role()).thenReturn(Role.CASHIER);&#10;        when(loginScreen.prompt()).thenReturn(mockSession);&#10;    }&#10;&#10;    private void setupManagerLoginScreenMock(LoginScreen loginScreen, MockedConstruction.Context context) {&#10;        AuthenticationUseCase.Session mockSession = mock(AuthenticationUseCase.Session.class);&#10;        when(mockSession.identifier()).thenReturn(&quot;manager&quot;);&#10;        when(mockSession.role()).thenReturn(Role.MANAGER);&#10;        when(loginScreen.prompt()).thenReturn(mockSession);&#10;    }&#10;&#10;    private void setupCashierMenuMock(CashierMenu cashierMenu, MockedConstruction.Context context) {&#10;        doNothing().when(cashierMenu).run();&#10;    }&#10;&#10;    private void setupManagerMenuMock(ManagerMenu managerMenu, MockedConstruction.Context context) {&#10;        doNothing().when(managerMenu).run();&#10;    }&#10;&#10;    private void setupWebShopMenuMock(WebShopMenu webShopMenu, MockedConstruction.Context context) {&#10;        doNothing().when(webShopMenu).start();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/domain/policies/FefoStrategyTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/domain/policies/FefoStrategyTest.java" />
              <option name="originalContent" value="package domain.policies;&#10;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.Mockito.*;&#10;&#10;import domain.policies.FefoStrategy;&#10;import domain.inventory.Batch;&#10;import domain.inventory.StockLocation;&#10;import domain.repository.InventoryRepository;&#10;import domain.shared.Code;&#10;import java.sql.Connection;&#10;import java.util.List;&#10;import java.util.ArrayList;&#10;&#10;@DisplayName(&quot;FefoStrategy Domain Policy Tests&quot;)&#10;class FefoStrategyTest {&#10;&#10;    private InventoryRepository inventoryRepository;&#10;    private Connection connection;&#10;    private Batch batch1;&#10;    private Batch batch2;&#10;&#10;    private FefoStrategy fefoStrategy;&#10;    private Code productCode;&#10;    private StockLocation stockLocation;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        inventoryRepository = mock(InventoryRepository.class);&#10;        connection = mock(Connection.class);&#10;        batch1 = mock(Batch.class);&#10;        batch2 = mock(Batch.class);&#10;&#10;        fefoStrategy = new FefoStrategy(inventoryRepository);&#10;        productCode = new Code(&quot;PROD001&quot;);&#10;        stockLocation = StockLocation.MAIN_STORE;&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should create FefoStrategy with inventory repository&quot;)&#10;    void shouldCreateFefoStrategyWithInventoryRepository() {&#10;        // When&#10;        FefoStrategy strategy = new FefoStrategy(inventoryRepository);&#10;&#10;        // Then&#10;        assertNotNull(strategy);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should fetch candidates from inventory repository&quot;)&#10;    void shouldFetchCandidatesFromInventoryRepository() {&#10;        // Given&#10;        List&lt;Batch&gt; expectedBatches = List.of(batch1, batch2);&#10;        when(inventoryRepository.findDeductionCandidates(connection, productCode, stockLocation))&#10;            .thenReturn(expectedBatches);&#10;&#10;        // When: call deductUpTo (which uses candidates under the hood)&#10;        fefoStrategy.deductUpTo(connection, productCode, 0, stockLocation);&#10;&#10;        // Then: verify repository was delegated to for candidates&#10;        verify(inventoryRepository).findDeductionCandidates(connection, productCode, stockLocation);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle empty candidates list&quot;)&#10;    void shouldHandleEmptyCandidatesList() {&#10;        // Given&#10;        List&lt;Batch&gt; emptyList = new ArrayList&lt;&gt;();&#10;        when(inventoryRepository.findDeductionCandidates(connection, productCode, stockLocation))&#10;            .thenReturn(emptyList);&#10;&#10;        // When&#10;        fefoStrategy.deductUpTo(connection, productCode, 0, stockLocation);&#10;&#10;        // Then&#10;        verify(inventoryRepository).findDeductionCandidates(connection, productCode, stockLocation);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should delegate to repository for proper FEFO ordering&quot;)&#10;    void shouldDelegateToRepositoryForProperFefoOrdering() {&#10;        // Given&#10;        List&lt;Batch&gt; orderedBatches = List.of(batch1, batch2);&#10;        when(inventoryRepository.findDeductionCandidates(connection, productCode, stockLocation))&#10;            .thenReturn(orderedBatches);&#10;&#10;        // When&#10;        fefoStrategy.deductUpTo(connection, productCode, 0, stockLocation);&#10;&#10;        // Then&#10;        // Verify the repository is called exactly once with correct parameters&#10;        verify(inventoryRepository, times(1)).findDeductionCandidates(connection, productCode, stockLocation);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should rely on repository for expiry date prioritization&quot;)&#10;    void shouldRelyOnRepositoryForExpiryDatePrioritization() {&#10;        // Given&#10;        List&lt;Batch&gt; expiryOrderedBatches = List.of(batch1, batch2);&#10;        when(inventoryRepository.findDeductionCandidates(connection, productCode, stockLocation))&#10;            .thenReturn(expiryOrderedBatches);&#10;&#10;        // When&#10;        fefoStrategy.deductUpTo(connection, productCode, 0, stockLocation);&#10;&#10;        // Then&#10;        // FEFO strategy relies on the repository's ordering which prioritizes earlier expiry first&#10;        verify(inventoryRepository).findDeductionCandidates(connection, productCode, stockLocation);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should not throw when inventory repository is null (constructor does not enforce)&quot;)&#10;    void shouldNotThrowWhenInventoryRepositoryIsNull() {&#10;        // When &amp; Then&#10;        assertDoesNotThrow(() -&gt; new FefoStrategy(null));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package domain.policies;&#10;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.BeforeEach;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.Mockito.*;&#10;&#10;import domain.policies.FefoStrategy;&#10;import domain.inventory.Batch;&#10;import domain.inventory.StockLocation;&#10;import domain.repository.InventoryRepository;&#10;import domain.shared.Code;&#10;import java.sql.Connection;&#10;import java.util.List;&#10;import java.util.ArrayList;&#10;&#10;@DisplayName(&quot;FefoStrategy Domain Policy Tests&quot;)&#10;class FefoStrategyTest {&#10;&#10;    private InventoryRepository inventoryRepository;&#10;    private Connection connection;&#10;    private Batch batch1;&#10;    private Batch batch2;&#10;&#10;    private FefoStrategy fefoStrategy;&#10;    private Code productCode;&#10;    private StockLocation stockLocation;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        inventoryRepository = mock(InventoryRepository.class);&#10;        connection = mock(Connection.class);&#10;        batch1 = mock(Batch.class);&#10;        batch2 = mock(Batch.class);&#10;&#10;        fefoStrategy = new FefoStrategy(inventoryRepository);&#10;        productCode = new Code(&quot;PROD001&quot;);&#10;        stockLocation = StockLocation.MAIN_STORE;&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should create FefoStrategy with inventory repository&quot;)&#10;    void shouldCreateFefoStrategyWithInventoryRepository() {&#10;        // When&#10;        FefoStrategy strategy = new FefoStrategy(inventoryRepository);&#10;&#10;        // Then&#10;        assertNotNull(strategy);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should fetch candidates from inventory repository&quot;)&#10;    void shouldFetchCandidatesFromInventoryRepository() {&#10;        // Given&#10;        List&lt;Batch&gt; expectedBatches = List.of(batch1, batch2);&#10;        when(inventoryRepository.findDeductionCandidates(connection, productCode, stockLocation))&#10;            .thenReturn(expectedBatches);&#10;&#10;        // When: call deductUpTo (which uses candidates under the hood)&#10;        fefoStrategy.deductUpTo(connection, productCode, 0, stockLocation);&#10;&#10;        // Then: verify repository was delegated to for candidates&#10;        verify(inventoryRepository).findDeductionCandidates(connection, productCode, stockLocation);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should handle empty candidates list&quot;)&#10;    void shouldHandleEmptyCandidatesList() {&#10;        // Given&#10;        List&lt;Batch&gt; emptyList = new ArrayList&lt;&gt;();&#10;        when(inventoryRepository.findDeductionCandidates(connection, productCode, stockLocation))&#10;            .thenReturn(emptyList);&#10;&#10;        // When&#10;        fefoStrategy.deductUpTo(connection, productCode, 0, stockLocation);&#10;&#10;        // Then&#10;        verify(inventoryRepository).findDeductionCandidates(connection, productCode, stockLocation);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should delegate to repository for proper FEFO ordering&quot;)&#10;    void shouldDelegateToRepositoryForProperFefoOrdering() {&#10;        // Given&#10;        List&lt;Batch&gt; orderedBatches = List.of(batch1, batch2);&#10;        when(inventoryRepository.findDeductionCandidates(connection, productCode, stockLocation))&#10;            .thenReturn(orderedBatches);&#10;&#10;        // When&#10;        fefoStrategy.deductUpTo(connection, productCode, 0, stockLocation);&#10;&#10;        // Then&#10;        // Verify the repository is called exactly once with correct parameters&#10;        verify(inventoryRepository, times(1)).findDeductionCandidates(connection, productCode, stockLocation);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should rely on repository for expiry date prioritization&quot;)&#10;    void shouldRelyOnRepositoryForExpiryDatePrioritization() {&#10;        // Given&#10;        List&lt;Batch&gt; expiryOrderedBatches = List.of(batch1, batch2);&#10;        when(inventoryRepository.findDeductionCandidates(connection, productCode, stockLocation))&#10;            .thenReturn(expiryOrderedBatches);&#10;&#10;        // When&#10;        fefoStrategy.deductUpTo(connection, productCode, 0, stockLocation);&#10;&#10;        // Then&#10;        // FEFO strategy relies on the repository's ordering which prioritizes earlier expiry first&#10;        verify(inventoryRepository).findDeductionCandidates(connection, productCode, stockLocation);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw exception when inventory repository is null&quot;)&#10;    void shouldThrowExceptionWhenInventoryRepositoryIsNull() {&#10;        // When &amp; Then&#10;        assertThrows(NullPointerException.class, () -&gt; new FefoStrategy(null));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>